/*
一.nim游戏
n堆石子，每一堆xi个，轮流取石子，每次从某堆中取石子，
至少取一个，无法取石子的玩家输

结论：  x1 ^ x2 ^ ... ^ xn = 0  P态
        x1 ^ x2 ^ ... ^ xn != 0  N态
证明:  
终态 0 ^ 0 ^ ... ^ 0 = 0  是P态
小范围内结论成立，下证任意范围都成立
对于任意 x1 ^ x2 ^ ... ^ xn = 0 无论如何取, x1 ^ x2 ^ ... ^ xi' ^ .. ^ xn != 0 
反证，如果 = 0 ,那么有 xi = xi' ,但是 对于任意 != 0 的情况 ，一定 有取法使得 = 0 ，因此是 N态
下面构造一种取法: 设 x1 ^ ... ^ xn = b1b2...bn 其中bi为二进制位
假设二进制中最高位1是 bi ,那么在x中寻找一个xj，使得xj的bi位为1，这样的xj一定存在
然后对于 bi+1 - bn ,如果 某一位是0，那么xj的这一位不变，否则，xj的这一位取反
这样，就得到了一个 xj',并且满足 xj' < xj ，x1 ^ ... ^ xj' ^ ... ^ xn = 0 是合法构造


二.反常nim游戏
无法取石子的玩家赢

结论：如果 x1 = x2 = ... = xn = 1, 
那么结论与nim相反 (异或和为0，N; 非0, P)
否则，结论与nim相同


三.类nim
每次操作可以选一堆石子 放或取 石子
结论仍然与nim一样，因为不管加或减，异或和 = 0 的，操作后一定 != 0 


四.分裂nim游戏
n堆石子，每次可以选某一堆取石子，或者将其分裂为两堆  正常规则
分析：拆成n个相同的组合游戏，只看一堆来分析，SG(0)=0,SG(1)=1,SG(2) = mex (0,1,1^1) = 2, ... 
打表得到结论 SG(0) = 0, SG(4k+1) = 4k+1, SG(4k+2) = 4k+2, SG(4k+3) = 4k+4, SG(4k+4) = 4k+3

如果是反常规则
仍然按照正常规则 来求得所有点的SG值，然后和反常nim一样，特判全1，如果全1，则结论相反


五.Fibonacci nim
初始有n个石子 先手第一次可取 1 - n-1 个石子，之后每一次可取的数量最多为上一个人取的两倍 不能取的输

结论：n = Fibonacci数  <=> n 是 P态 ，n != Fibonacci数  <=> n 是 N态

Zeckendorf定理: 每个正整数都可以唯一的写成若干个不相邻的 Fibonacci数(不包括第一个Fib数,1,2,3,5,8)的和
如何得到这种表示：每次贪心地选取小于等于n的最大的Fibonacci数

必胜策略 ：1. 若 n != Fib数，假设 n = Fx1 + Fx2 + ... + Fxk , 其中 xi 递减，则取 Fxk,即最小项
            n 变成 Fx1 + Fx2 + ... + Fxk-1 , 由于 Fxk-1 > 2Fxk ,因此后手不可能取完最后一项
           故最终只会是先手将n取完，先手胜
          2. 若 n = Fib = Fx，假设先手取m个，m < Fx
           (1)若 m >= Fx-2 , 那么有 Fx - m <= Fx - Fx-2 = Fx-1 < 2 * Fx-2 ,因此后手直接取 Fx - m
           (2)若 m < Fx-2 && m >= Fx-4 , 取 Fx-2 - m, 剩下 Fx-1,此时下一轮先手并不能一次取完
           (3)若 m < Fx-4 && m >= Fx-6 , 取 Fx-4 - m, 剩下 Fx-1 + Fx-3,且下一轮先手并不能取完 Fx-3
           ... 
           实际操作时，n - m = Fx1 + Fx2 + ... + Fxk，后手取 Fxk 且一定可以取到(由上面的(1)(2)(3)可证)

七.k倍动态减法
有n个石子 先手第一次可取 1 - n-1 个石子，之后每一次可取的数量最多为上一个人取的 k倍 不能取的输

1.k=1
结论: n = 2^i  <=>  n是 P态      n != 2^i   <=>   n是N态
必胜策略 (证明) 
 (1) n != 2^i ,先手取 n 的二进制表示的最后一位1，故后手并不能拿走倒数第二位1，因此并不能一次取完
     故最终一定是n只剩1个1，然后先手取走 
 (2) n = 2^i ,由于先手不能取完， 因此先手取完后，后手一定可以取到最后一位1

2.k=2
Fibonacci nim

3.k>2
需要构造某个数列，这个数列满足的性质是，任何正整数都能被数列中若干项表示出来，且表示的这几项满足
ax1 > k * ax2 , ax2 > k * ax3, ...
假设已经构造出了前i-1个数，第i个数ai, 前i-1项所能构造出来的最大数是 bi-1，那么有 ai = bi-1 + 1
如何更新bi : 找到 满足 ai > k * aj 最大的 j， 那么 bi = ai + bj
构造出以后，如果 n = 数列中的某一项 ,那么是 P态,否则是 N态；
最优策略仍然是 将n用数列若干项表示，然后取最小的那一项
*/
// hdu 2486
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair<int,int> pii;

const int mod=1e9+7,N=1e6+10;

int n,m,k;
int a[N],b[N],tot;

void print()
{
    int res=0;
    for(int i=tot;i>=1;i--)
        if(n>=a[i]) n-=a[i],res=a[i];
    printf("%d\n",res);
}

void solve()
{
    a[1]=1,b[1]=1,tot=1;
    cin >> n >> k;
    for(int i=2,j=1;a[i-1]<n;i++)
    {
        a[i]=b[i-1]+1,tot++;
        while((ll)k*a[j+1]<a[i]) j++;
        if(a[j]*k<a[i]) b[i]=a[i]+b[j];
        else b[i]=a[i];
    }
    if(a[tot]==n) printf("lose\n");
    else print();
}

int main()
{
    int _;
    cin >> _;
    for(int i=1;i<=_;i++)
    {
        printf("Case %d: ",i);
        solve();
    }
    return 0;
}
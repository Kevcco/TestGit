/*
 数组连续子序列的异或问题 ：  转化为两点问题 
    使用前缀和 O(1) 计算某一段的异或和，s[l,r]=prefix_s[r]^prefix_s[l-1]
    问题转化为找两个数l,r，求所有s[l-1]^s[r] 这个集合里的信息
 两个变量l,r,
 可以枚举r，使用 hash表 或者 trie 优化l的选择 时间复杂度降到 O(n) or O(nlogC)

一. 寻找异或和是特定值

    (1)求异或和为0的连续子序列个数   /   求数对[i,j] 使得 a[i]^a[j]=0 的数对个数
            从左到右遍历，枚举r，找到 0 - r-1 中s[i]==s[r] 的个数, 
            可以从左到右遍历，每次用hash记录当前值，枚举到i时,hash已经记录了1 - i-1 的值
            注意一开始hash[0]=1，表示s[0],一个都不选的异或和是0
             O(n)

    (2)将一个数组划分成多个子区间，求划分方式，使得异或和为0的子区间的数量最多，输出最大数量
            贪心：枚举r，每次第一次找到异或和为0的子区间，就划分一下，一定更优于更大的r的划分
            也就是每次找到后，清空hash表，从当前的r开始计入hash表，不再考虑r之前的

    (3)找出数组的连续子序列 异或值是完全平方数（包括0） 的个数
            依旧是枚举 r ，考虑 hash 优化 l 
            s[r]^s[l-1]=C  s[l-1]=c^s[r]
            因此直接枚举完全平方数 c 每次 for(all c) res+=hash[s[r]^c] 
            枚举范围： s[i]^s[j]=c,c最大不会超过 2*n 一堆 <=n 的数异或 最大不会大于 2n

    (4)求异或和是x的连续子序列个数
            s[r]^s[l-1]=x; s[l-1]=s[r]^x;

二.寻找异或最值

    (1)最大异或对 / 最大连续子序列异或值 ：求数组中任意两个数最大异或值     
            对于a[r],找a[1]-a[r-1](如果可以选重复就是到a[r])中的最大的a[i]^a[r]
            可以用trie优化，从高位到低位建trie，寻找时贪心找    O(log ai)
            O( n * log ai)

    (2)求 长度不超过k的 连续子序列 最大异或和
            固定r，变成求长度为k的滑动窗口中两数异或最大，依旧用trie，一旦窗口长度大于k，
            就删除最前面的数，可以对所有的节点维护一个 cnt[N] 来实现trie删除操作

    (3)求最小异或对 : n个数排序后 最小的相邻异或对的值
        证明: a < b < c 下证明 a^c > a^b or b^c
             假设a和c 从高到低 第一个不同的位是第k位 则 ck=1 ak=0
             若 bk=0 则 a^c > a^b 若bk=1 则 a^c > b^c
             得证

三.求所有异或对
     (1)求给定数组中 所有异或对（两数异或后）的加法和   n<=1e6
           枚举r,考虑所有1 - r-1 的数异或a[r] 的和
           按位拆分：考虑这些数每一位对答案的贡献：如果这一位和a[r]相同，无贡献，不同，贡献一个 1<<j
           因此可以记录所有1 - r-1的数每一位的0和1的个数，对于每一位
           res+=(1<<j) * cnt[j][a[i]>>j&1^1]

   ~~~   (2)求 1 - n 这n个数中 [l,r] 这一段的所有异或对 的加法和   n<=1e18
           不能枚举r了，直接考虑所有数中第j位为1的数有多少个，假设x个
           则对答案的贡献是  res+=(1<<j) *  (n-x)*x/2  n为总数  
           (n-x)*x/2是 0 1 组合的个数
           则可以用数位dp，统计每位1的个数  O(logn)

   ~~~   (3) 求给定数组中 所有异或对 前k小的数
           可持久化

四.求所有的连续子区间

     (1)求所有的连续子序列异或值的加法和
           前缀和转化成异或对，变成问题 三 (1)

  ~~~   (2)求所有连续子区间加法和的异或值
            前缀和转化为减法，按位拆分，考虑答案的每一位，要求统计 所有区间和的这一位上 1的个数
            如果是奇数，则对答案有贡献，否则无贡献
            统计 si - sj 某一位上是1的个数   权值树状数组 

     (3)求所有连续子区间且长度不超过k的异或值的和
           前缀和转化成异或对，变成问题 三 (1) 区间限制转化为滑动窗口 每次超过窗口长度就需要
           删除最前面的数

     (4)求所有连续子区间且长度是偶数（奇数）的异或值的加法和
           将下标分奇偶 ，统计数位01时也分奇偶，
           每次枚举到下标是奇数的数的时候，就有奇数的cnt[]计算，反之同理

五.多次区间询问

     (1)多次询问，每次询问求区间出现偶数次数的数的异或和    n,m <= 1e6
           结论: 区间出现奇数次数的数的异或值 = 区间异或值 
                 区间出现偶数次数的数的异或值 = 区间出现过的数的异或值 ^ 区间异或值

            区间异或值: 前缀和
            区间出现过的数的异或值：离线操作，按照询问的右端点排序，从左到右处理，
                相同的数只保留最后一次出现的数  比如处理1-r
                则sum(i)表示1 - i中只出现一次,并且没有在i+1 - r 中出现过的数
                或者说sum(i) 表示对于 1 - r 而言 1 - i 中元素新出现的个数
                则[l,r] = sum[l-1] ^ sum[r]  树状数组维护
            cf 703 D
            这种去重思想也适用于求区间出现过的数的加和
            hdu 3333  Luogu 1972

六.线性基

*/
/*
# 一：01背包问题
    （1）二维        时间 O（N*V） 空间O（N*V）
    （2）空间优化    时间 O（N*V） 空间O（V）

# 二：完全背包问题
    （1）朴素 三层循环      时间 O（N*V*V/vi） 空间 O（V）
    （2）简单优化：计数排序，在相同v中只保留w最大的（完全背包独有的优化方式）
    （3）打包思想：一件变成V/vi件物品，再二进制打包，变为01背包
    （4）最优 两层循环      时间 O（N*V）      空间 O（V）

# 三：多重背包问题
    （1）朴素                        时间 O（N*V*s）    空间 O（V）
    （2）二进制优化：打包变为01背包    时间 O（N*V*logs） 空间 O（V+N*logs）
    （3）单调队列优化                 时间 O（N*V）      空间 O（V）

# 四：混合三种背包
    （1）多重转换成01，状态转移时分 01 和 完全 两种方式（简洁，时间界可接受）
    （2）直接三种方式转移  （时间最优）

# 五：二维费用的背包
    （1）约束条件变为二维：1.体积 2.重量（件数...)   dp[v][m]
         对一维的扩展，思想与一维一样

# 六：分组背包问题
    （1）三层循环，可看成多重背包问题的一般性情况，似乎无优化  时间O（N*V*S）

# 七：有依赖的背包问题

# 八：初始化相关
    状态表示：
    1.体积恰好是j：  f[0][0]=0,f[0][1-m]=-inf; 循环的时候j=m;j>=v;j--
                    答案不一定是f[i][j]，必须循环找
    2.体积至多是j：  f[0][0-m]=0;  循环也是 j>=v;
    3.体积至少是j：  f[0][0]=0,f[0][1-m]=inf; 循环  j=m;j>=0;
                    因为当j<v时也是合法状态，这一个物品就能让体积>j 更新的话可以用f[max(0,j-v)]
                    详细见AcWing 1020 潜水员

# 九：输出方案问题
    1.输出方案
    （1）基本思路：保留二维，即保留中间状态， 从后往前比较状态 反推转移的路径
                    物品的信息也必须存下来，才能反推路径，不能循环内读
                或者开一个二维的记录数组，在推的过程中保存是怎么转移过来的
    2.输出字典序最优方案
    （2）用1的思路即可，字典序则要求对于从小到大的第i个物品，能选则选
        一个技巧是让i从n开始，即逆序选择物品（相应地，状态转移是从i+1转移到i层），
        这样从后向前反推路径（i从1到n）时物品是正序

# 十：求方案总数
    1.求恰好装满背包的方案数
    （1）基本思路: f[i][j]=f[i-1][j]+f[i-1][j-v]                 （01背包）
                  f[i][j]=f[i-1][j]+f[i][j-v]                   （完全背包）
                  f[i][j]=f[i-1][j]+f[i-1][j-v]+...+f[i-1][j-s*v] (预处理前缀和）（多重背包）
        初始化：f[0][0]=1,f[0][1-m]=0;
    2.求最优解的方案数
    （1）两个数组，f[i][j]和g[i][j]，f[i][j]求最大值，g[i][j]求方案数
            01背包
            若f[i-1][j]==f[i-1][j-v]+w,则g[i][j]=g[i-1][j]+g[i-1][j-v];
            若f[i-1][j]>f[i-1][j-v]+w,则g[i][j]=g[i-1][j];
            若f[i-1][j]<f[i-1][j-v]+w,则g[i][j]=g[i-1][j-v];
            完全背包
            若f[i-1][j]==f[i][j-v]+w,则g[i][j]=g[i-1][j]+g[i][j-v];
            若f[i-1][j]>f[i][j-v]+w,则g[i][j]=g[i-1][j];
            若f[i-1][j]<f[i][j-v]+w,则g[i][j]=g[i][j-v];
        初始化 f[0][0-m]=0,可以不装满背包，g[0][0-m]=1，表示有一种方案

# 十一：求第k优解
    （1）给f[j]开一个k数组f[j][k]，表示此状态下降序的前k个最大值，
        01背包：f[i][j][k]  考虑转移  不选i的前k优解 和 选i的前k优解 合并
                f[i-1][j-v][1-k]+w 和 f[i-1][j][1-k] 这两个长度为k的数组合并
        完全背包: 对 f[j],f[j-v]+w 和普通的一样的优化思路 
                f[i][j]  f[i-1][j] 和 f[i][j-v]+w 合并 即可

        初始化:  1.f[0][1]=0,其他赋成负无穷,恰好装满背包的前k优解
        初始化:  2.f[0-m][1]=0,其他赋成负无穷,小于等于背包的前k优解

*/
/*一个排列 a  ，每次可以交换任意两个数，求将其排序所需要的最少操作次数

置换环：将i和a[i]之间连边  i->a[i] 再将a[i]当成新的i :i->a[i] -> a[a[i]] 直到连成一个环
例如：
     1 2 3 4 5 6 7 8
     1 7 5 8 2 6 3 4

    1->1    2->7->3->5->2  4->8->4  有三个置换环
    将原排列排序也就等价于变成n个(自)环 i->i（因为自环意味着已经在正确位置了）
    
考虑由两个及以上结点组成的环，每次交换两个数相当于交换指针（箭头），这样一个环会裂成两个环
   2->7->3->5->2  交换2的箭头和3的箭头(交换7和5)，变成 2->5->2 和 7->3->7
                  交换2的箭头和7的箭头(7,3)   2->3->5->2 and 7->7 

(两个置换环，每个置换环各取一点交换，两个合并成一个)

因此由k个结点组成的环需要k-1次操作,变成k个自环

因此，一个包含k个置换环的排列，最少需要操作n-k次

将i和a[i]连边 如何找所有在环上的元素？
利用拓扑排序：如果元素在环上 那么一定不会入队 因此拓扑排序后所有没有入队的元素就是成环的元素


# 1.cf 842 D
    将给定的排列变成只有一个逆序对的排列，求最少的交换次数

    最后一定变成一个自然排列，只有某一对相邻的元素调换了位置的排列
    考虑置换环2->3->2 可以不用动，这样可以减少一次操作
    因此判断每个置换环中是否有相邻元素，如果有，res=n-k-1
    如果没有，就需要再手动多换一次，res=n-k+1

# 2.cf 797 F
    给定长度相等的字符串和排列，每操作一次，字符串就按排列顺序变化 
    a b c d         b c a d
    3 1 2 4   ->    3 1 2 4


    将字符串也变成1 2 3 4 
    1 2 3 4
    3 1 2 4
    考虑某一个置换环 1->3->2->1 意味着操作一次，位置1上的字母变成了原位置3上的字母，操作两次变成2，操作三次变回1   对于3和2而言也是一样的
    因此具有循环节，找到所有置换环的循环节，求最小公倍数便是答案
    k个结点的置换环循环数最大是k，但是因为可能有重复字母，循环节可能更小
    考虑直接模拟，1 3 2  操作一次变成 3 2 1 再操作变成 2 1 3
    因此用链表模拟，每次将头插入尾，再删去头 与原链表比较即可

# 3.cf 789 E

# 4.cf edu141 F

*/
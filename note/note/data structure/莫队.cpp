/*
一.普通莫队

对于离线区间询问  并且两段区间的信息很难合并  而加/删一个数 信息可以O(1)维护时 可以用莫队

将区间分成 根号n 块 将询问按照左端点所在的块的编号排序 如果块相同 那么 让右端点单调排序
一般将奇数块的右端点递减 偶数块右端点递增 这样常数较小
然后对于排好序的每一个询问 使用双指针来将上一个区间的信息 通过加/删 变成下一个区间的信息

复杂度分析 
对于右指针 在每一块内由于是单调的 因此最多移动 O(n) 因此根号n块 总O(n * 根号n)
                     而块间移动每次最坏O(根号n) 因此 总 O(n * 根号n) (加上奇偶性优化一般可以忽略块间移动)
对于左指针 在块内 每一次询问是O(根号n) 因此是 O(m * 根号n)
          在块间 每一次最坏移动 O(根号n) 最多移动根号n块 因此是 O(n)
因此指针移动的总时间复杂度是 O(n * 根号n  +  m * 根号n)
求答案的时间复杂度是 O(m * x) x为求一次答案所需的时间 最高可以支持 O(根号n)
更一般的 如果每一块长度定为 x  那么 O(n * n / a  +  m * a)                                                                    
所以块的大小 size = sqrt(n*n/m) 此时 总时间 O( n * sqrt(m))
注意加/删信息一定要是O(1) 
查询最多可以是O(根号n) 比如分块 此时时间为 O(n * n / a + m * a + m * a) 取 sqrt(n*n/2/m)

代码:块的大小可以取定值 也可以根据 n，m 大小取合适的值
     指针移动的四个while 一定要先add 再del 不然cnt[x]可能会出现负值

信息维护: 
(1) 区间不重复的数的个数: 开一个桶 每次加/删 实时维护个数
(2) 区间中选两个数 值相同的概率 ans = res / c(len,2) 其中 res = sum c(x,2) x为其中某一个元素出现的次数
    转移 : c(x,2) -> c(x+1,2) 因此 res += x   c(x,2) -> c(x-1,2)  res -= x-1
(3) 区间中出现k次的元素的个数：开一个桶 记录每个元素的出现次数 开一个 vis[] 记录出现i次的元素的个数
(4) 区间中众数出现的次数 : 桶 + vis 数组记录出现i次的元素的个数
莫队套分块:
(1) 每个询问询问一段区间[l,r]内的元素在值域[a,b]中出现的次数和不重复出现的次数
    直接对值域分块 对一整块维护元素和 查询 O(根号n)
(2) 询问一段区间[l,r]的mex
    仍然是值域分块 对一整块维护sum[]表示块内出现的元素个数

Luogu P1494
Luogu P2709
Luogu P3709
Luogu P4462
Acwing P4657
Luogu P4369


二.带修莫队

普通莫队是不能修改的
对于带修改的题 需要加一维时间戳t t个修改操作分别是 1 - t q个询问操作加一维t代表询问所处的时间
对于一个询问 有 l r t 三维 每次三个指针都要转移 l r 先转移 t后转移
当然对于t的转移 也要能够在O(1)完成
t如何转移：如果修改的元素在[l,r]中 相当于add新元素 del旧元素 如果不在就没有影响
           然后将原数组的元素修改 并将修改操作交换 假设a[i]=x 本来操作是 a[i]=y 现在是 a[i]=x
排序: 三关键字: l所处的块，r所处的块，如果l，r所处的块都相同 那么让t单调

时间复杂度分析: 假设块长a
l指针: 块内: a * q 块间 2a * n/a = 2n
r指针: 块内：a * q 块间 a * n/a * n/a = n*n/a
t指针：每一个l，r 块：t * n/a * n/a = t*n*n/a/a
总 O(a * q + t * n^2 / a^2) 
取 a = cbrt(n*n*t/q)  总 O(n^2/3 * q^2/3 * t^1/3) 其中 t + q = m 总操作


Luogu P1903


三.回滚莫队

如果能够O(1)加一个元素 但是删一个元素很困难 (比如最大值)
或者O(1)删一个元素 但是加一个元素很困难 (比如区间mex)     可以考虑回滚莫队
大部分和普通莫队一样 

只加不删的莫队: 只维护不会变短的小区间[right+1,r] 少的部分[l,right]每次暴力加 
               然后回滚 没有用到删 相当于直接舍弃[l,right]的信息 

按l所在块编号排序 块相同的让r升序排列 询问排好序后 考虑 l 在同一块的一组询问
先处理掉 l 和 r 在同一块内的询问 直接暴力即可 信息不用保留
考虑剩下的询问 r是单增的 假设l所在的块的右端点是right
每次询问 只实时维护[right+1,r] 这一段的信息 每次转移[right+1,old r] -> [right+1,new r]
转移完后 先将此时维护好的res备份 
然后[l,right]这一段 直接暴力加即可 得到[l,r]答案
然后回滚：res回滚成备份 再将[l,right]这一段暴力删去 
相当于回滚成[right+1,r]这一段的信息了 供下一个区间使用
同一块内的询问处理完后 需要将信息清空 然后处理下一块

时间复杂度分析：
暴力处理的区间 : O(m * a)
右指针 O(n/a * n )
左指针 O(m * a)
清空数组 O(n/a * n)
总 O(n*n/a + m*a) 比普通莫队常数大一点


只删不加的莫队: 只维护不会变长的大区间 [left,r] 多的部分[left,l-1]每次暴力删  没有用到加

让r降序排列 对于 l在同一块的一组询问
l r在同一块的仍然暴力处理 假设l所在块的左端点为left
然后先预处理[left,max r]这一段的信息 然后一直实时维护[left,r]的信息
对于某一询问 维护好[left,old r]->[left,new r] 的信息后 备份 
然后将[left,l-1] 的信息删除 得到[l,r]正确答案
然后回滚到[left,r]

luogu AT_joisc2014_c
Luogu P4137


四.树上莫队
利用括号序，将两个点之间的路径变为连续的区间
具体而言 设 l[u] < l[v]
(1)若 lca(u,v) = u 则 u,v 之间的路径就是括号序列中 [l[u], l[v]]这一段里只出现一次的节点
(2)否则, u,v 之间的路径就是 [r[u], l[v]] 这一段里只出现一次的节点 + lca这个节点
然后就转化成了区间查询 就是普通莫队
但是如何维护区间信息？
因为只计算只出现一次的点 开一个cnt[]记录点的权值信息，同时开vis[u] 记录编号为u的这个点的出现次数 
一旦vis[u]为偶数，就要删除这个点的权值信息

树上带修 ： 如何判断待修改的点在区间内且只出现一次 ： st[x]=1

Luogu SP10707
Luogu P4070



五.二次离线莫队
在普通莫队的基础上 将更新答案(指针移动)的过程再次离线处理
具体而言 设加点与删点的时间复杂度是 O(k) 那么普通莫队时间复杂度是O(n*根号n*k)
用二次离线莫队 可以变成 O(n*k + n*根号n)
常见的题目是求一段区间 满足某些性质的 点对个数
那么在扩展时 r -> r+1 答案需要增加 [l,r]这一段中 和 r+1 配对的个数
利用前缀和 f(l,r) = f(1,r) - f(1,l-1)
[1,r]和 r+1 配对的个数可以提前预处理 O(1)更新
[1,l-1]和 r+1 配对的个数就存下来离线处理
那么对于完整的 R -> r ( R < r )
res += sum( f[1,i]和i+1配对的个数 )     R <= i < r
然后离线存下来要处理的 [1,L-1] 中分别和 [R,r-1]这个区间每一个数配对的个数

将所有需要处理的离线存下来之后 
让要处理的区间单调 i from 1 to n 
每次把i加入区间  变成[1,i]
然后处理[1,i] 这个区间的所有询问
处理区间是 O(n*k)
处理每一个区间的询问是 O(n*根号n) 就是指针的移动次数

Luogu P4887



六.总结
莫队 = 指针移动 + 询问答案    一定要保证指针一次移动是O(1)的，难以直接维护的信息可以在询问时再O(根号n)处理
指针移动 ： 普通莫队， 带修莫队加一维指针， 回滚莫队指针回滚， 
询问答案 ： O(1)， 分块 O(根号n)，

树上莫队 ： 欧拉序转化为区间
二次离线莫队 ： 将指针移动再次离线，一定要用 O(根号n)或者O(logn)插入  O(1)查询 的数据结构来求答案
                因为查询次数 = 指针移动次数 O(n根号n)

*/
#include <bits/stdc++.h>

using namespace std;

const int N=14e4+10,S=1e6+10;

int n,m,tot,qot,len;
int cnt[S],a[N],res,ans[N];
struct q
{
    int id,l,r,t;
}Q[N];

struct
{
    int x,y;
}M[N];

bool cmp(q &a,q &b)
{
    if(a.l/len!=b.l/len) return a.l<b.l;
    if(a.r/len!=b.r/len) return a.r<b.r;
    if(a.r/len&1) return a.t>b.t;
    return a.t<b.t;
}

inline void add(int x)
{
    if(!cnt[x]) res++;
    cnt[x]++;
}

inline void del(int x)
{
    cnt[x]--;
    if(!cnt[x]) res--;
}

inline void changet(int l,int r,int t)
{
    int x=M[t].x,y=M[t].y;
    if(x>=l&&x<=r) add(y),del(a[x]);
    M[t].y=a[x],a[x]=y;
}

int main()
{
    cin >> n >> m;
    for(int i=1;i<=n;i++) scanf("%d",a+i);
    for(int i=1;i<=m;i++)
    {
        char str[2];
        int x,y;
        scanf("%s%d%d",str,&x,&y);
        if(*str=='R')
        {
            ++tot;
            M[tot]={x,y};
        }
        else qot++,Q[qot]={qot,x,y,tot};
    }
    
    len=cbrt((double)n*n*max(1,tot)/qot)+1;
    sort(Q+1,Q+qot+1,cmp);
    
    for(int k=1,i=1,j=0,tt=0;k<=qot;k++)
    {
        int l=Q[k].l,r=Q[k].r,t=Q[k].t;
        while(j<r) add(a[++j]);
        while(i>l) add(a[--i]);
        while(j>r) del(a[j--]);
        while(i<l) del(a[i++]);
        while(tt<t) changet(i,j,++tt);
        while(tt>t) changet(i,j,tt--);
        ans[Q[k].id]=res;
    }
    
    for(int i=1;i<=qot;i++) printf("%d\n",ans[i]);
    
    return 0;
}
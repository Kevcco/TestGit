/*
一.nim游戏
n堆石子，每一堆xi个，轮流取石子，每次从某堆中取石子，至少取一个，无法取石子的玩家输

结论：  x1 ^ x2 ^ ... ^ xn = 0  P态
        x1 ^ x2 ^ ... ^ xn != 0  N态
证明:  终态 0 ^ 0 ^ ... ^ 0 = 0  是P态
       小范围内结论成立，下证任意范围都成立
       对于任意 x1 ^ x2 ^ ... ^ xn = 0 无论如何取, x1 ^ x2 ^ ... ^ xi' ^ .. ^ xn != 0 
       反证，如果 = 0 ,那么有 xi = xi' ,但是 对于任意 != 0 的情况 ，一定 有取法使得 = 0 ，因此是 N态
       下面构造一种取法: 设 x1 ^ ... ^ xn = b1b2...bn 其中bi为二进制位
       假设二进制中最高位1是 bi ,那么在x中寻找一个xj，使得xj的bi位为1，这样的xj一定存在
       然后对于 bi+1 - bn ,如果 某一位是0，那么xj的这一位不变，否则，xj的这一位取反
       这样，就得到了一个 xj',并且满足 xj' < xj ，x1 ^ ... ^ xj' ^ ... ^ xn = 0 是合法构造


二.反常nim游戏
无法取石子的玩家赢

结论：如果 x1 = x2 = ... = xn = 1, 那么结论与nim相反 (异或和为0，N; 非0, P)
      否则，结论与nim相同
证明：1.对于全是1的情况,0个1是N态，而奇数个1只能到偶数个1，偶数个1能到奇数个1，故结论成立
     2.对于存在大于1的情况：
        2.1 若异或和 = 0，那么任取之后 ，异或和 != 0 ,并且不会全是1，故是P态
        下证取完之后不会全是1：反证,若全是1，那么取之前一定是 1 ^ 1 ^ ... ^ 1 ^ xi = 0
        那么 xi 只能是 0/1 ，故与存在大于1的前提矛盾
        2.2 若异或和 != 0,分两种情况
            2.2.1若只有一个 > 1 的，那么 如果是奇数，那么将 > 1 的取成 1，变成奇数个 1，
                如果是偶数，那么将 > 1 的取走，也变成奇数个1(P态)  故是 N态
            2.2.2 若至少有两个 > 1 的数，那么按照nim游戏的取法取后， 异或和 = 0，且不全为1


三.类nim
每次操作可以选一堆石子 放或取 石子
结论仍然与nim一样，因为不管加或减，异或和 = 0 的，操作后一定 != 0 


四.从SG函数来看nim游戏
将一堆石子看作一个游戏，石子个数看成节点，那么 SGi(0)=0,SGi(1)=1,...,SGi(x)=x
故总的 SG(G) = x1 ^ x2 ^ x3 ^ ... ^ xn


五.分裂nim游戏
n堆石子，每次可以选某一堆取石子，或者将其分裂为两堆  正常规则
分析：拆成n个相同的组合游戏，只看一堆来分析，SG(0)=0,SG(1)=1,SG(2) = mex (0,1,1^1) = 2, ... 
打表得到结论 SG(0) = 0, SG(4k+1) = 4k+1, SG(4k+2) = 4k+2, SG(4k+3) = 4k+4, SG(4k+4) = 4k+3

可用数学归纳法证明 小范围成立，假设 <x 的都成立
(1) SG(4k+1) 只考虑取，SG(4k+1) = 4k+1, 那么只需证 不管怎么分裂 SG(a) ^ SG(b) != 4k+1
    4k+1 可以分裂成 4a 和 4b + 1 , SG(4a)=4a-1,SG(4b+1)=4b+1, 故SG(4a) ^ SG(4b+1) <= 4a-1 + 4b+1 < 4k+1 
    或者分裂成 4a+2 和 4b+3, SG(4a+2) = 4a+2, SG(4b+3) = 4b+4  SG(4a+2) ^ SG(4b+3) 一定是偶数,故得证
(2) SG(4k+2) 只考虑取 = 4k+2 , 再证 SG(a) ^ SG(b) != 4k+2
    可以分裂成 4a+1,4b+1, SG(4a+1) ^ SG(4b+1) = (4a+1) ^ (4b+1) < 4a+1 + 4b+1 = 4k+2 （奇数与奇数异或）
    或者 4a, 4b+2, SG(4a) ^ SG(4b+2) = (4a-1) ^ (4b+2) <= 4a-1 + 4b+2 < 4k+2  得证 
(3) SG(4k+3) 只考虑取 = 4k+3 , 再证 SG(a) ^ SG(b)  1. = 4k+3 ，2. != 4k+4
    1.构造 1,4k+2,那么 SG(1) ^ SG(4k+2) = 1 ^ (4k+2) = 1 + 4k+2 = 4k+3  
    2.分裂成4a+1,4b+2, 那么SG() ^ SG() = (4a+1) ^ (4b+2) <= 4k+3
      或者分裂成 4a ,4b+3 ,那么SG() ^ SG() <= 4a-1 + 4b+4 = 4k+3 得证
(4) SG(4k+4) 只考虑取 = 4k+3 , 再证 SG(a) ^ SG(b) != 4k+3
    可以分裂成 4a,4b, SG(4a) ^ SG(4b) = (4a-1) ^ (4b-1) <= 4a-1 + 4b-1 < 4k+4
    或者 4a+1, 4b+3, SG() ^ SG() = (4a+1) ^ (4b+4) 考虑二进制最后三位，一定是101,100,故^后一定是 001
    或者 4a+2,4b+2, SG() ^ SG() = (4a+2) ^ (4b+2) 二进制最后一位一定是0，故得证 

如果是反常规则
仍然按照正常规则 来求得所有点的SG值，然后和反常nim一样，特判全1，如果全1，则结论相反


六.Fibonacci nim
初始有n个石子 先手第一次可取 1 - n-1 个石子，之后每一次可取的数量最多为上一个人取的两倍 不能取的输

结论：n = Fibonacci数  <=> n 是 P态 ，n != Fibonacci数  <=> n 是 N态

Zeckendorf定理: 每个正整数都可以唯一的写成若干个不相邻的 Fibonacci数(不包括第一个Fib数,1,2,3,5,8)的和
如何得到这种表示：每次贪心地选取小于等于n的最大的Fibonacci数
证明：1，2，3显然成立，归纳法, 假设 < x 的都可以表示出来，那么找到 < x 的最大的项 Fi
      有  Fi <= x < Fi+1 那么有 x - Fi < Fi+1 - Fi = Fi-1 ,由归纳假设知 x - Fi 可以被表示
      且由于 x - Fi < Fi-1 ,故被表示的项一定不会包括 Fi-1,故 x 可以写成不相邻的Fibonacci数的和
再证明唯一: 假设存在某一次操作不取 最大的Fib数Fi，而是取 Fj, j<i   Fi <= x < Fi+1
           那么最大的合法取法就是 Fi-1 + Fi-3 + ... + F1/F2
           1. Fi-1 + ... + F1 < F0(F0=1) + F1 + F3 + ... + Fi-1 = F2 + F3 +... + Fi-1 = Fi < x
           2. Fi-1 + ... + F2 < F1 + F2 + F4 + ... + Fi-1 = Fi < x
           故不可能构造出x，因此按上述构造方法是唯一的表示 

必胜策略 ：1. 若 n != Fib数，假设 n = Fx1 + Fx2 + ... + Fxk , 其中 xi 递减，则取 Fxk,即最小项
            n 变成 Fx1 + Fx2 + ... + Fxk-1 , 由于 Fxk-1 > 2Fxk ,因此后手不可能取完最后一项
           故最终只会是先手将n取完，先手胜
          2. 若 n = Fib = Fx，假设先手取m个，m < Fx
           (1)若 m >= Fx-2 , 那么有 Fx - m <= Fx - Fx-2 = Fx-1 < 2 * Fx-2 ,因此后手直接取 Fx - m
           (2)若 m < Fx-2 && m >= Fx-4 , 取 Fx-2 - m, 剩下 Fx-1,此时下一轮先手并不能一次取完
           (3)若 m < Fx-4 && m >= Fx-6 , 取 Fx-4 - m, 剩下 Fx-1 + Fx-3,且下一轮先手并不能取完 Fx-3
           ... 
           实际操作时，n - m = Fx1 + Fx2 + ... + Fxk，后手取 Fxk 且一定可以取到(由上面的(1)(2)(3)可证)

七.k倍动态减法
有n个石子 先手第一次可取 1 - n-1 个石子，之后每一次可取的数量最多为上一个人取的 k倍 不能取的输

1.k=1
结论: n = 2^i  <=>  n是 P态      n != 2^i   <=>   n是N态
必胜策略 (证明) 
 (1) n != 2^i ,先手取 n 的二进制表示的最后一位1，故后手并不能拿走倒数第二位1，因此并不能一次取完
     故最终一定是n只剩1个1，然后先手取走 
 (2) n = 2^i ,由于先手不能取完， 因此先手取完后，后手一定可以取到最后一位1

2.k=2
Fibonacci nim

3.k>2
需要构造某个数列，这个数列满足的性质是，任何正整数都能被数列中若干项表示出来，且表示的这几项满足
ax1 > k * ax2 , ax2 > k * ax3, ...
假设已经构造出了前i-1个数，第i个数ai, 前i-1项所能构造出来的最大数是 bi-1，那么有 ai = bi-1 + 1
如何更新bi : 找到 满足 ai > k * aj 最大的 j， 那么 bi = ai + bj
构造出以后，如果 n = 数列中的某一项 ,那么是 P态,否则是 N态；
最优策略仍然是 将n用数列若干项表示，然后取最小的那一项
     
*/

// hdu 2486
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair<int,int> pii;

const int mod=1e9+7,N=1e6+10;

int n,m,k;
int a[N],b[N],tot;

void print()
{
    int res=0;
    for(int i=tot;i>=1;i--)
        if(n>=a[i]) n-=a[i],res=a[i];
    printf("%d\n",res);
}

void solve()
{
    a[1]=1,b[1]=1,tot=1;
    cin >> n >> k;
    for(int i=2,j=1;a[i-1]<n;i++)
    {
        a[i]=b[i-1]+1,tot++;
        while((ll)k*a[j+1]<a[i]) j++;
        if(a[j]*k<a[i]) b[i]=a[i]+b[j];
        else b[i]=a[i];
    }
    if(a[tot]==n) printf("lose\n");
    else print();
}

int main()
{
    int _;
    cin >> _;
    for(int i=1;i<=_;i++)
    {
        printf("Case %d: ",i);
        solve();
    }
    return 0;
}